1.为什么要学习O(n^2)的排序算法？

* 基础
* 编码简单，易于实现，是一些简单情景的首选
* 在一些特殊情况下，简单的排序算法更有效
* 简单的排序算法思想衍生出复杂的排序算法
* 作为子过程，改进更复杂的排序算法

2.排序算法需要注意的问题

* 输入数据是否近乎有序
* 输入数据量大小，是否需要考虑外部排序
* 输入数据的范围是否存在大量重复元素，并且在在很小的区间内，如颜色、年龄等.

3.十大排序算法

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存.

常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等.

常见的外部排序算法有：计数排序、桶排序

* 冒泡排序

Bubble Sort	：交换排序方法.比较相邻的元素，如果他们的顺序错误就把他们交换过来.

	什么时候最快？	当输入的数据已经是正序时
	什么时候最慢？	当输入的数据是反序时
* 选择排序

Selection Sort：每次都在未排序数组中找到最小的元素，放到起始位置.

	无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了.
* 插入排序	

Insertion Sort：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入.

	插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入.
	
* 希尔排序	

Shell Sort：也称递减增量排序算法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法.先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序.

	希尔排序是基于插入排序的以下两点性质而提出改进方法的：
	* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
	* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
	
* 归并排序

Merge Sort：是采用分治法（Divide and Conquer）的一个非常典型的应用，和选择排序一样，归并排序的**性能不受输入数据的影响**，但表现比选择排序好的多，代价是需要额外的内存空间. 典型的使用空间换时间. 将*arr[l...mid]*和*arr[mid+1...r]*两部分进行归并.

	作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
	* 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
	* 自下而上的迭代；

* 快速排序

Quick Sort：交换排序方法，快速排序又是一种分而治之思想在排序算法上的典型应用，使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）.快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

从数列中挑出一个元素，称为"基准"(pivot);重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)，在这个分区退出之后，该基准就处于数列的中间位置.这个称为分区（partition）操作;递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序.

双路快速排序可以解决处理输入数据为近乎有序的数组和未排序的序列包含大量相同元素的数组.对于包含有大量重复数据的数组, 三路快排有巨大的优势，java中，三路快排是默认的语言库函数中使用的排序算法，对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围.

	《算法艺术与信息学竞赛》
	快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。
	但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。
	所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

* 堆排序

Heap Sort：利用堆这种数据结构所设计的一种排序算法。堆积是一个近似**完全二叉树**的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序.算法的核心操作是，首先选择大顶堆或小顶堆，其次把堆首（最大值）和堆尾互换，把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置，直到堆的尺寸为 1.

	大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
	小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
* 计数排序

Counting Sort：非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法. 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中. 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数.
	
	首先找到序列最大值
	开辟最大值个空间，对序列进行计数
	返回不为零的数据，完成排序

* 桶排序

Bucket Sort：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定. 为了使桶排序更加高效，我们需要做到以下两点：

	在额外空间充足的情况下，尽量增大桶的数量
	使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要.

	什么时候最快?		当输入的数据可以均匀的分配到每一个桶中.
	什么时候最慢?		当输入的数据被分配到了同一个桶中.

总体思路是，首先找到序列最大值与最小值，然后利用映射函数将数据分配到各个桶中，最后对每个桶进行排序，比如使用插入排序.
	
* 基数排序

Radix Sort：分配式排序 distribution sort，一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数. 基数排序的方式可以采用LSD（Least sgnificant digital）或MSD（Most sgnificant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始. 

	基数排序：根据键值的每位数字来分配桶
	计数排序：每个桶只存储单一键值
	桶排序：每个桶存储一定范围的数值

LSD算法的核心思路是，首先通过得到最大数字获取列表中最高位数，然后根据各个不同位数将数据分配到各个桶中，最后将各个数字从桶中取出完成排序.

![sort](../../resource/sort.png)

### 关于时间复杂度：

* 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序;
* 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序;
* O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数, 希尔排序
* 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序.

### 关于稳定性：

* 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序.
* 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序.

### 名词解释：

* n：数据规模
* k：“桶”的个数

* In-place：占用常数内存，不占用额外内存
* Out-place：占用额外内存

* 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

4.其他排序算法

* TimSort 一种混合、稳定高效的排序算法，源自合并排序和插入排序，旨在很好地处理多种真实数据。它由Tim Peters于2002年实施使用在Python编程语言中.[python代码](https://blog.csdn.net/sinat_35678407/article/details/82974174)
* CubeSort 并行排序算法.
* CocktailSort	鸡尾酒排序又称双向冒泡排序、鸡尾酒搅拌排序、搅拌排序、涟漪排序、来回排序或快乐小时排序, 是冒泡排序的一种变形。该算法与冒泡排序的不同处在于排序时是以双向在序列中进行.
* TreeSelectSort	锦标赛排序(胜者树)也叫树选择排序，是一种按照锦标赛的思想进行选择的排序方法，该方法是在简单选择排序方法上的改进，我们知道简单选择排序时间大部分都浪费在值的比较上面，而锦标赛排序刚好用树保存了前面比较的结果，下一次比较时直接利用前面比较的结果大大减少比较的时间，从而降低了时间复杂度，由O(n^2)降到O(nlogn)，但是浪费了比较多的空间，“最大的值”也比较了多次. 为了弥补此缺憾，威廉姆斯于1964年提出了堆排序.
* GnomeSort/StupidSort，侏儒排序、地精排序，和插入排序类似，除了移动一个元素到最终的位置，是通过交换一系列的元素实现，就像冒泡排序一样。概念上十分简单，不需要嵌套循环。时间复杂度为O(n2),但是如果初始数列基本有序，时间复杂度将降为O(n)。实际上Gnome算法可以和插入排序算法一样快。平均运行时间为O(n2).Gnome排序算法总是查找最开始逆序的一对相邻数，并交换位置，基于交换两元素后将引入一个新的相邻逆序对，并没有假定当前位置之后的元素已经有序.
* PancakeSort	煎饼排序，leetcode-969，指的是将大小不同的一摞煎饼按大小排序的数学问题，其中煎饼铲子每次只能从任意位置铲起上方全部煎饼并翻面。“煎饼数”（英语：pancake number）是指给定煎饼的张数时，最坏情况下需要的最少翻面次数。这个问题最早由美国几何学家雅可比·古德曼提出。它属于排序问题的变种。煎饼排序的目标和传统排序算法最小化比较次数不同，因为它每次操作只允许反转序列的前缀，所以需要最小化反转前缀次数。焦煎饼排序是煎饼排序的变种问题，每张煎饼都有一面是烤焦的，最终除了按照大小排序以外还要让所有焦面向下.
* CombSort	梳子排序，由Wlodzimierz Dobosiewicz于1980年所发明的不稳定排序算法，并由Stephen Lacey和Richard Box于1991年四月号的Byte杂志中推广。梳排序是改良自泡沫排序和快速排序.
* 表插入排序 
* OddEvenSort	奇偶排序，思路是在数组中重复两趟扫描。第一趟扫描选择所有的数据项对，a[j]和a[j+1]，j是奇数(j=1, 3, 5……)。如果它们的关键字的值次序颠倒，就交换它们。第二趟扫描对所有的偶数数据项进行同样的操作(j=2, 4,6……)。重复进行这样两趟的排序直到数组全部有序. 实际上《Java数据结构和算法》中有描述，在多处理器环境中很有用，处理器可以分别同时处理每一个奇数对，然后又同时处理偶数对。因为奇数对是彼此独立的，每一刻都可以用不同的处理器比较和交换。这样可以非常快速地排序.
* 鸽巢排序 Pigeonhole sort：鸽巢排序的执行速度快于任何一种排序，但其却需要很大的辅助空间，而且其适用于很少的数值范围内的排序。当待排序数组中出现很多不相等的元素是，鸽巢排序的效率会降低。

---
以下排序方法为比较皮的骚操作，前方高能：）

* SleepSort	休眠排序，用到多线程
* BogoSort	猴子排序，一组数字，随机一次，若随机后的结果不是有序的，再随机一次。。。直到随机的结果是有序的，理论上，只要时间足够长，必定能排好序。就像一组无序的扑克牌，让猴子打乱一次，若还是无序的，猴子再打乱一次. 这是多看脸的算法啊...
* SpaghettiSort	一组数字array，再来一把面条，array里的最大值对应面条的高度，数字和面条高度由此可以得到一个系数，这个系数就是数字数值和面条高度的映射关系（比如，数字是 1到10，面条是十根，每一根面条都是高度10，那这个系数就是1），array里的数字对应每一根面条，再把多出的高度给折掉，最终就得到长短不一的十根面条，然后把十根面条放桌子上端平，用手平行于桌面，从上往下，最先碰到手的，先拿开。这样面条排好序了，array也排好序了. 感觉纯属扯淡.

## TODO：

* 更多排序算法

## 参考资料
1. GitBook 在线书籍 [《十大经典排序算法》](https://sort.hust.cc/) [github](https://github.com/hustcc/JS-Sorting-Algorithm)

2. 慕课网