1.为什么要学习O(n^2)的排序算法？

* 基础
* 编码简单，易于实现，是一些简单情景的首选
* 在一些特殊情况下，简单的排序算法更有效
* 简单的排序算法思想衍生出复杂的排序算法
* 作为子过程，改进更复杂的排序算法

2.排序算法需要注意的问题

* 输入数据是否近乎有序
* 输入数据量大小，是否需要考虑外部排序
* 输入数据的范围是否存在大量重复元素，并且在在很小的区间内，如颜色、年龄等.

3.十大排序算法

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存.

常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等.

常见的外部排序算法有：计数排序、桶排序

* 冒泡排序

Bubble Sort	：交换排序方法.比较相邻的元素，如果他们的顺序错误就把他们交换过来.

	什么时候最快？	当输入的数据已经是正序时
	什么时候最慢？	当输入的数据是反序时
* 选择排序

Selection Sort：每次都在未排序数组中找到最小的元素，放到起始位置.

	无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了.
* 插入排序	

Insertion Sort：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入.

	插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入.
	
* 希尔排序	

Shell Sort：也称递减增量排序算法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法.先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序.

	希尔排序是基于插入排序的以下两点性质而提出改进方法的：
	* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
	* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
	
* 归并排序

Merge Sort：是采用分治法（Divide and Conquer）的一个非常典型的应用，和选择排序一样，归并排序的**性能不受输入数据的影响**，但表现比选择排序好的多，代价是需要额外的内存空间. 典型的使用空间换时间. 将*arr[l...mid]*和*arr[mid+1...r]*两部分进行归并.

	作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
	* 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
	* 自下而上的迭代；

* 快速排序

Quick Sort：交换排序方法，快速排序又是一种分而治之思想在排序算法上的典型应用，使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）.快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

从数列中挑出一个元素，称为"基准"(pivot);重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)，在这个分区退出之后，该基准就处于数列的中间位置.这个称为分区（partition）操作;递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序.

双路快速排序可以解决处理输入数据为近乎有序的数组和未排序的序列包含大量相同元素的数组.对于包含有大量重复数据的数组, 三路快排有巨大的优势，java中，三路快排是默认的语言库函数中使用的排序算法，对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围.

	《算法艺术与信息学竞赛》
	快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。
	但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。
	所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

* 堆排序

Heap Sort：利用堆这种数据结构所设计的一种排序算法。堆积是一个近似**完全二叉树**的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序.算法的核心操作是，首先选择大顶堆或小顶堆，其次把堆首（最大值）和堆尾互换，把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置，直到堆的尺寸为 1.

	大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
	小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
* 计数排序

Counting Sort：非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法. 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中. 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数.
	
	首先找到序列最大值
	开辟最大值个空间，对序列进行计数
	返回不为零的数据，完成排序

* 桶排序

Bucket Sort：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定. 为了使桶排序更加高效，我们需要做到以下两点：

	在额外空间充足的情况下，尽量增大桶的数量
	使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要.

	什么时候最快?		当输入的数据可以均匀的分配到每一个桶中.
	什么时候最慢?		当输入的数据被分配到了同一个桶中.

总体思路是，首先找到序列最大值与最小值，然后利用映射函数将数据分配到各个桶中，最后对每个桶进行排序，比如使用插入排序.
	
* 基数排序

Radix Sort：分配式排序 distribution sort，一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数. 基数排序的方式可以采用LSD（Least sgnificant digital）或MSD（Most sgnificant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始. 

	基数排序：根据键值的每位数字来分配桶
	计数排序：每个桶只存储单一键值
	桶排序：每个桶存储一定范围的数值

算法的核心思路是，首先找出列表中最大的位数，

![sort](../../resource/sort.png)

### 关于时间复杂度：

* 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序;
* 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序;
* O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数, 希尔排序
* 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序.

### 关于稳定性：

* 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序.
* 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序.

### 名词解释：

* n：数据规模
* k：“桶”的个数

* In-place：占用常数内存，不占用额外内存
* Out-place：占用额外内存

* 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

4.其他排序算法

* TimSort 一种混合、稳定高效的排序算法，源自合并排序和插入排序，旨在很好地处理多种真实数据。它由Tim Peters于2002年实施使用在Python编程语言中.[python代码](https://blog.csdn.net/sinat_35678407/article/details/82974174)
* TreeSort TreeSelectionSort，树形选择排序。虽然树形选择比较能够减少比较次数，却增加了辅助空间的使用。为了弥补此缺憾，威廉姆斯于1964年提出了堆排序.
* CubeSort 并行排序算法.

## TODO：

* 更多排序算法

## 参考资料
1. GitBook 在线书籍 [《十大经典排序算法》](https://sort.hust.cc/) [github](https://github.com/hustcc/JS-Sorting-Algorithm)

2. 慕课网